Main pg_autoctl commands
========================

pg_auto_failover includes the command line tool ``pg_autoctl`` that
implements many commands to manage your Postgres nodes. To implement the
Postgres architectures described in this documentation, and more, it is
generally possible to use only a couple of the many ``pg_autoctl`` commands.

This section of the documentation is a short introduction to the main
commands that are useful when getting started with pg_auto_failover. More
commands can be useful in some cases, see the :ref:`reference` for the whole
list.

To understand which replication settings to use in your case, see
:ref:`architecture_basics` section and then the
:ref:`multi_node_architecture` section.

To follow a step by step guide that you can reproduce on your own Azure
subscription and create a production Postgres setup from VMs, see the
:ref:`tutorial` section.

Command line environment, configuration files, etc
--------------------------------------------------

As a command line tool ``pg_autoctl`` depends on some environment variables.
Mostly, the tool re-uses the Postgres environment variables that you might
already know.

To manage a Postgres node pg_auto_failover needs to know its data directory
location on-disk. For that, some users will find it easier to export the
``PGDATA`` variable in their environment. The alternative consists of always
using the ``--pgdata`` option that is available to all the ``pg_autoctl``
commands.

Creating Postgres Nodes
-----------------------

To get started with the simplest Postgres failover setup, 3 nodes are
needed: the pg_auto_failover monitor, and 2 Postgres nodes that will get
assigned roles by the monitor. One Postgres node will be assigned the
primary role, the other one will get assigned the secondary role.

To create the monitor use the command::

  $ pg_autoctl create monitor

The create the Postgres nodes use the command::

  $ pg_autoctl create postgres

Those commands will initialize your nodes, now you have to actually run the
Postgres service that are expected to be running. For that you can manually
run the following command on every node::

  $ pg_autoctl run

It is also possible (and recommanded) to integrate the pg_auto_failover
service right in your usual service management facility. You can use the
following command to produce the unit file configuration that systemd
requires, and then you can install it and enable the systemd unit::

  $ pg_autoctl show systemd

While it is expected that for a production deployment each node actually is
a separate machine (virtual or physical, or even a container), it is also
possible to run several Postgres nodes all on the same machine for testing
or development purposes.

Inspecting nodes
----------------

Once your Postgres nodes have been created, and once each ``pg_autoctl``
service is running, it is possible to inspect the current state of the
formation with the following command::

  $ pg_autoctl show state

To analyze what's been happening to get to the current state, it is possible
to review the past events generated by the pg_auto_failover monitor with the
following command::

  $ pg_autoctl show events

Editing Replication Settings
----------------------------

When creating node it is possible to use the ``--candidate-priority`` and
the ``--replication-quorum`` options to set the replication properties as
required by your choice of Postgres architecture.

To review the current replication settings of a formation, use the following
command::

  $ pg_autoctl get formation settings

It is also possible to edit those replication settings at any time while
your nodes are in production: you can change your mind or adjust to new
elements without having to re-deploy everything. Just use the following
commands to adjust the replication settings on the fly::

  $ pg_autoctl set formation number-sync-standbys
  $ pg_autoctl set node replication-quorum
  $ pg_autoctl set node candidate-priority


Implementing Maintenance Operations
-----------------------------------

When a Postgres node must be taken offline for a maintenance operation, such
as e.g. a kernel security upgrade or a minor Postgres update, it is best to
make it so that the pg_auto_failover monitor knows about it. This prevents a
failover to target a node that's schedule to not be available anymore, and
depending on your replication settings smoothly ensures that the primary
node switches to async replication before Postgres is shut down on the
secondary, avoiding write queries to be blocked.

To implement maintenance operations, use the following commands::

  $ pg_autoctl enable maintenance
  $ pg_autoctl disable maintenance

The main ``pg_autoctl run`` service that is expected to be running in the
background should continue to run during the whole maintenance operation.
When a node is in the maintenance state, the ``pg_autoctl`` service is not
controlling the Postgres service anymore.

Note that it is possible to enable maintenance on a primary Postgres node,
and that operation then requires a failover to happen first. It is possible
to have pg_auto_failover orchestrate that for you when using the command::

  $ pg_autoctl enable maintenance --allow-failover

Manual failover, switchover, and promotions
-------------------------------------------

In the cases when a failover is needed without having an actual node
failure, the pg_auto_failover monitor can be used to orchestrate the
operation. Use one of the following commands::

  $ pg_autoctl perform failover
  $ pg_autoctl perform switchover

Finally, it is also possible to “elect” a new primary node in your formation
with the command::

  $ pg_autoctl perform promotion

What's next?
------------

This section of the documentation is meant to help users get started by
focusing on the main commands of the ``pg_autoctl`` tool. Each command has
many options that can have very small impact, or pretty big impact in terms
of security or architecture. Read the rest of the manual to understand how
to best use the many ``pg_autoctl`` options to implement your specific
Postgres production architecture.
